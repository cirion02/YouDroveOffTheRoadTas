<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta charset="utf-8">
<!--
Published on 2023-07-09 by Ian Henderson.
This software belongs to a future without copyright.  Please use it however you'd like.
-->
<!--
Tas-tools injected by Cirion02
-->
<title>You drove off the road!</title>
<meta name='viewport' content='width=800'>
<style>
body {
	margin: 0;
	padding: 0;
	background-color: #ecb;
	text-align: center;
	user-select: none;
	-webkit-user-select: none;
	font-family: Georgia;
}
canvas {
	width: 800px;
	height: 800px;
}
#debug {
	position: absolute;
	top: 0;
	left: 0;
	background-color: white;
	color: black;
}
#trail, #track {
	display: none;
}
button {
	background-color: #c33;
	color: #fff;
	touch-action: manipulation;
	font-size: 24px;
	font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
	font-weight: bold;
	border: none;
	border-radius: 16px;
	padding: 15px 30px;
}
button:disabled {
	background-color: #a87;
}
.error button {
	background-color: #023;
	color: #eff;
}
.playing button, .playing #message, .buttons-only #message {
	display: none;
}
main {
	display: inline-block;
	position: relative;
	overflow: hidden;
	width: 800px;
	height: 800px;
}
.bottom-right {
	position: absolute;
	bottom: 50px;
	right: 50px;
}
.bottom-left {
	position: absolute;
	bottom: 50px;
	left: 50px;
}
#next-level-button {
	position: absolute;
	bottom: 50px;
	right: 50px;
	display: none;
}
#previous-level-button {
	position: absolute;
	bottom: 50px;
	left: 50px;
	display: none;
}
.level-select #next-level-button, .level-select #previous-level-button {
	display: unset;
}
#level-buttons button {
	position: absolute;
	display: none;
	font-size: 20px;
	width: 150px;
	height: 150px;
	padding: 12px;
	font-weight: normal;
	background-color: #371604;
	border: 3px solid #fee;
}
#level-buttons button.required {
	border-style: double;
	border-width: 9px;
}
#level-buttons button.required.completed {
	border-style: solid;
	border-width: 3px;
}
#level-buttons button.completed {
	background-color: #a87 !important;
	color: #100 !important;
}
#level-buttons button .time {
	font-family: 'Georgia';
	margin-top: 4px;
}
.level-select .bottom-right, .level-select .bottom-left {
	display: none;
}
.level-select #message {
	bottom: unset;
	top: 0;
	font-size: 36px;
	background: none;
	color: #433;
}
.level-select #level-buttons button {
	display: unset;
}
.title-screen .bottom-right {
	display: none;
}
.title-screen .bottom-left {
	bottom: 100px;
	left: 100px;
	right: 100px;
	min-width: -moz-available;
}
#message {
	position: absolute;
	font-size: 96px;
	font-weight: bold;
	color: #c33;
	padding: 20px;
	left: 0;
	right: 0;
	bottom: 380px;
	background-color: #fff;
	pointer-events: none;
}
#subtitle {
	position: absolute;
	font-size: 32px;
	color: #433;
	padding: 20px;
	left: 0;
	right: 0;
	bottom: 230px;
	pointer-events: none;
	display: none;
}
.title-screen #subtitle {
	display: unset;
}
.loaded #subtitle {
	display: block;
	bottom: unset;
	top: 10px;
}
.finish #message, .loaded #message, .ending #message {
	backdrop-filter: invert() hue-rotate(180deg);
	-webkit-backdrop-filter: invert() hue-rotate(180deg);
	background-color: unset;
	color: #fff;
}
.error #message {
	backdrop-filter: invert();
	-webkit-backdrop-filter: invert();
	color: #eff;
	background-color: unset;
}
.finish #message {
	bottom: unset;
	top: 100px;
}
.loaded .bottom-right, .loaded #message, .ending .bottom-right {
	display: none;
}
#ending-text {
	position: absolute;
	left: 10%;
	right: 10%;
	top: 100%;
	font-size: 32px;
	line-height: 1.5em;
}

table {
   position:absolute;
   top:20px;
   right:60px;
}

td {
	border:1px solid black;
	padding: 3px;
}

</style>
</head>
<body class="vsc-initialized">
<main class="title-screen">
	<canvas id="main" style="width: 800px; height: 800px;" width="640" height="640"></canvas>
	<div id="ending-text" style="transform: translate(0px);">
		<p>a game by Ian Henderson (aka panic#9031) for 1d1p 47 “sign”</p>
		<p>released on 9 July 2023</p>
		<p>shoutout to the folks in witscord, in particular raz and sus for 
	hosting 1d1p and coming up with the cool theme.  also thanks to 
	thefifthmatt and Cirion02 for useful feedback!</p>
		<p>congrats on finishing the game and i hope you have a good rest of your day</p>
	</div>
	<div id="level-buttons"></div>
	<button id="bottom-right-button" class="bottom-right"></button>
	<button id="bottom-left-button" class="bottom-left">START GAME</button>
	<button id="previous-level-button">PREVIOUS</button>
	<button id="next-level-button">NEXT</button>
	<span id="message" style="transform: translate(0px);">You drove off the road!</span>
	<span id="subtitle">a puzzle racing game by panic#9031</span>
	</main>
	<canvas id="trail" width="640" height="640"></canvas>
	<pre id="debug"></pre>
	
<table id="timer">
	<tr>
		<td style="visibility: collapse;"></td>
		<td style="visibility: collapse;">-0:00.000-</td>
	</tr>
	<tr id="totalRow">
		<td>Total</td>
		<td id="totalTime">0:00.000</td>
	</tr>
</table>
<canvas id='track'></canvas>
<canvas id='trail'></canvas>
<pre id='debug'></pre>
<p id="tas-info"></p>


<script src="levels.js"></script>
<script>
'use strict';
const canvas = document.getElementById('main');
const trail = document.getElementById('trail');
const track = document.getElementById('track');
const originalDevicePixelRatio = window.devicePixelRatio;
const viewportWidth = 800;
const viewportHeight = 800;

const trackDataScale = 0.25;
const trackDataWidth = viewportWidth * trackDataScale;
const trackDataHeight = viewportHeight * trackDataScale;
const trackData = new Uint8Array(trackDataWidth * trackDataHeight);

const trailScale = originalDevicePixelRatio;

let carX;
let carY;
let facingX;
let facingY;
let speed;
let dtRemainder = 0;
let canFinishRace;
let gameState = 'title';
let msUntilGameOverMessage;
const msUntilGameOverMessageMax = 20;
let stopMS;
let ignoreInputMS;
let gameOverMessage;
let gameOverMessageClassName;
let tickFactor;
let raceTimer;
let raceTimerMinutes;
let newRecord;
let introSlideFactor;
const introSlideDistance = 0;
const introSlideFactorDeceleration = 0;

let endingStartMS = 0;
let endingMS = 0;
const endingMSMax = 780;

const pointsInTrail = new Float32Array(120 * 2000);
let numberOfPointsInTrail;

let startFinishFacingX;
let startFinishFacingY;

let controllerX = 300;
let controllerY = 300;
let controllerPressed = false;

const groups = [
	'world 1',
	'world 2',
	'world 3',
	'world 4',
];
let currentGroup = 0;

const levelsByGroup = {};
for (let i = 0; i < levels.length; ++i) {
	const level = levels[i];
	if (!levelsByGroup[level.group])
		levelsByGroup[level.group] = [];
	levelsByGroup[level.group].push(level);
	const persisted = localStorage.getItem(level.name);
	// const persisted = null;
	if (persisted) {
		const p = JSON.parse(persisted);
		level.bestTimeMinutes = p.bestTimeMinutes;
		level.bestTime = p.bestTime;
	}
}
while (currentGroup < groups.length) {
	let skipGroup = true;
	for (const level of levelsByGroup[groups[currentGroup]]) {
		if (level.name === 'level-background' || level.name === 'free drive')
			continue;
		if (!level.bestTime && !level.bestTimeMinutes) {
			skipGroup = false;
			break;
		}
	}
	if (skipGroup)
		currentGroup++;
	else
		break;
}
if (currentGroup >= groups.length)
	currentGroup = 0;

let currentLevel = 0;

let points = [];
let chains = [];
let directionIndicators = [];

let activeIndexInChain = [];
let activePreviousPointForChain = [];
let activeProgressInChain = [];
let objects = [];

const carLength = 24;
const carWidth = 12;
const trackWidth = 72;
const startFinishWidth = 24;
const signWidth = 28;
const trackAllowanceFactor = 1.17;

function load() {
	points = levels[currentLevel].points;
	chains = levels[currentLevel].chains;
	directionIndicators = levels[currentLevel].directionIndicators;
	objects = JSON.parse(JSON.stringify(levels[currentLevel].signs));
	activeIndexInChain.length = chains.length;
	activePreviousPointForChain.length = chains.length;
	activeProgressInChain.length = chains.length;
	activePreviousPointForChain[0] = 0;
	for (let i in chains) {
		const chain = chains[i];
		activeIndexInChain[i] = -1;
		activePreviousPointForChain[i] = 0;
		activeProgressInChain[i] = 0;
		for (let j = 1; j < chain.length; ++j) {
			if (chain[j] === 0)
				activePreviousPointForChain[0] = chain[j - 1];
		}
	}
	activeIndexInChain[0] = 0;
	activeProgressInChain[0] = -999;
	carX = points[chains[0][0]];
	carY = points[chains[0][0] + 1];
	facingX = points[chains[0][1]] - carX;
	facingY = points[chains[0][1] + 1] - carY;
	if (forceStartPosX !== undefined){
		carX = forceStartPosX;
		carY = forceStartPosY;
		if (forceCarFace !== undefined){
			facingX = forceCarFace[0] - carX;
			facingY = forceCarFace[1] - carY;
		}
	}
	const len = Math.sqrt(facingX * facingX + facingY * facingY);
	facingX /= len;
	facingY /= len;
	startFinishFacingX = facingX;
	startFinishFacingY = facingY;
	carX -= facingX * startFinishWidth;
	carY -= facingY * startFinishWidth;
	speed = 0;
	tickFactor = 1;
	stopMS = 0;
	ignoreInputMS = 0;
	msUntilGameOverMessage = 0;
	gameOverMessageClassName = '';
	raceTimer = 0;
	raceTimerMinutes = 0;
	newRecord = false;
	for (const object of objects) {
		object.flashMS = 0;
		object.maxDestroyMS = object.destructable ? 400 : 0;
		object.destroyMS = 0;
		object.destroyed = false;
		object.vx = 0;
		object.vy = 0;
		object.tilt = 0;
	}
	trail.getContext('2d').clearRect(0, 0, trail.width, trail.height);
	numberOfPointsInTrail = 0;
	canFinishRace = false;
	introSlideFactor = 1;
}
document.getElementById('bottom-right-button').onclick = function (event) {
	// let justWon = gameState === 'game-over' && gameOverMessageClassName === 'finish';
	load();
	// if (justWon) {
	// 	gameState = 'loaded';
	// 	document.querySelector('main').className = 'loaded';
	// 	document.getElementById('bottom-left-button').textContent = 'LEAVE';
	// } else {
		gameState = 'starting';
		document.querySelector('main').className = 'playing';
	// }
	redraw();
};
document.getElementById('next-level-button').onclick = function (event) {
	if (currentGroup + 1 < groups.length) {
		currentGroup++;
		levelSelect();
	} else {
		for (let i = 0; i < levels.length; ++i) {
			if (levels[i].ending) {
				setLevel(i);
				break;
			}
		}
	}
};
document.getElementById('previous-level-button').onclick = function (event) {
	if (currentGroup - 1 >= 0) {
		currentGroup--;
		levelSelect();
	} else
		showTitleScreen();
};
function showTitleScreen() {
	endingStartMS = 0;
	endingMS = 0;
	gameState = 'title';
	document.getElementById('bottom-left-button').textContent = 'START GAME';
	document.getElementById('message').textContent = 'You drove off the road!';
	document.getElementById('subtitle').textContent = 'a puzzle racing game by panic#9031';
	document.querySelector('main').className = 'title-screen';
	redraw();
}

function rasterizeTrack(begin, end) {
	let minX = 0;
	let maxX = trackDataWidth - 1;
	let minY = 0;
	let maxY = trackDataHeight - 1;
	const beginX = points[begin] * trackDataScale;
	const beginY = points[begin + 1] * trackDataScale;
	const endX = points[end] * trackDataScale;
	const endY = points[end + 1] * trackDataScale;
	const r = trackWidth / 2 * trackAllowanceFactor * trackDataScale + 0.5;
	minX = Math.floor(Math.max(minX, Math.min(beginX - r, endX - r)));
	minY = Math.floor(Math.max(minY, Math.min(beginY - r, endY - r)));
	maxX = Math.ceil(Math.min(maxX, Math.max(beginX + r, endX + r)));
	maxY = Math.ceil(Math.min(maxY, Math.max(beginY + r, endY + r)));
	const offsetX = endX - beginX;
	const offsetY = endY - beginY;
	const offsetLength2 = offsetX * offsetX + offsetY * offsetY;
	for (let y = minY; y <= maxY; y++) {
		for (let x = minX; x <= maxX; x++) {
			const dx = x - beginX;
			const dy = y - beginY;
			const t = Math.max(0, Math.min(1, (offsetX * dx + offsetY * dy) / offsetLength2));
			const projX = beginX + t * offsetX - x;
			const projY = beginY + t * offsetY - y;
			if (projX * projX + projY * projY <= r * r)
				trackData[y * trackDataWidth + x] = 255;
		}
	}
}

function setLevel(levelIndex) {
	const level = levels[levelIndex];
	currentLevel = levelIndex;
	load();
	gameState = 'loaded';
	document.getElementById('bottom-left-button').textContent = level.ending ? 'PREVIOUS' : 'BACK';
	document.getElementById('bottom-right-button').textContent = 'START';
	document.getElementById('subtitle').textContent = level.tutorial ? level.tutorial : '';
	document.querySelector('main').className = 'loaded';

	trackData.fill(0);

	for (const chain of chains) {
		for (let i = 1; i < chain.length; ++i)
			rasterizeTrack(chain[i - 1], chain[i]);
	}
	redraw();
}

function levelSelect() {
	endingStartMS = 0;
	endingMS = 0;
	gameState = 'level-select';
	document.getElementById('message').textContent = '';//groups[currentGroup];
	document.querySelector('main').className = 'level-select';
	const buttonsContainer = document.getElementById('level-buttons');
	buttonsContainer.innerHTML = '';
	let unlocksNeeded = 0;
	let unlocksFinished = 0;
	for (let i = 0; i < levels.length; ++i) {
		const level = levels[i];
		if (level.group !== groups[currentGroup])
			continue;
		if (level.name === 'level-background') {
			currentLevel = i;
			load();
			continue;
		}
		const button = document.createElement('button');
		let requiredClass = '';
		if (level.required)
			requiredClass = ' required';
		let time = '';
		if (level.bestTime > 0 || level.bestTimeMinutes > 0) {
			time = `<div class='time'>${formatTime(level.bestTimeMinutes, level.bestTime)}</div>`;
			button.className = `level completed${requiredClass}`;
			if (level.required)
				unlocksFinished++;
		} else
			button.className = `level${requiredClass}`;
		button.dataset.levelIndex = i;
		button.style = level.overworldStyle;
		button.innerHTML = `<b>${escapeHTML(level.name)}</b>${time}`;
		button.onclick = function (event) {
			setLevel(i);
		};
		buttonsContainer.appendChild(button);
		if (level.required)
			unlocksNeeded++;
	}
	document.getElementById('previous-level-button').style.display = currentGroup - 1 >= 0 ? '' : 'none';
	document.getElementById('next-level-button').disabled = false;
	document.getElementById('next-level-button').textContent = 'NEXT';
	if (unlocksFinished < unlocksNeeded) {
		document.getElementById('next-level-button').textContent = `${unlocksFinished} / ${unlocksNeeded}`;
		document.getElementById('next-level-button').disabled = true;
	}
	redraw();
}
document.getElementById('bottom-left-button').onclick = levelSelect;

function escapeHTML(string) {
	return string.replace(/&/g, '&amp;').replace(/</g, '&lt;');
}

function formatTime(mins, ms) {
	const timerSeconds = `00000${ms}`.slice(-5);
	return `${mins}:${timerSeconds.slice(0, 2)}.${timerSeconds.slice(2, 5)}`;
}

function project(x1, y1, x2, y2) {
	return (x1 * x2 + y1 * y2) / (x2 * x2 + y2 * y2);
}
function updateProgress() {
	let debugString = ' /';
	for (let i in chains) {
		const chain = chains[i];
		const activeIndex = activeIndexInChain[i];
		if (activeIndex < 0) {
			debugString = `${debugString} ${i} ${activeIndex} /`;
			continue;
		}
		const x = points[chain[activeIndex]];
		const y = points[chain[activeIndex] + 1];
		const carOffsetX = carX - x;
		const carOffsetY = carY - y;
		const prevX = points[activePreviousPointForChain[i]] - x;
		const prevY = points[activePreviousPointForChain[i] + 1] - y;
		const nextX = points[chain[activeIndex + 1]] - x;
		const nextY = points[chain[activeIndex + 1] + 1] - y;
		const prevLen = Math.sqrt(prevX * prevX + prevY * prevY);
		const nextLen = Math.sqrt(nextX * nextX + nextY * nextY);
		const tPrev = project(carOffsetX, carOffsetY, prevX, prevY);
		const tNext = project(carOffsetX, carOffsetY, nextX, nextY);
		const which = tNext * nextLen > tPrev * prevLen;
		const len = which ? nextLen : prevLen;
		const progress = which ? Math.max(0, tNext) : -Math.max(0, tPrev);
		const chainX = which ? nextX * tNext : prevX * tPrev;
		const chainY = which ? nextY * tNext : prevY * tPrev;
		if (progress > activeProgressInChain[i])
			activeProgressInChain[i] = progress;
		else if (progress < activeProgressInChain[i] - 10 / len)
			activeIndexInChain[i] = -2;

		const d2 = (chainX - carOffsetX) * (chainX - carOffsetX) + (chainY - carOffsetY) * (chainY - carOffsetY);
		const progressOffRoadFactor = 0.75 + 1.5 * Math.max(0, tNext);
		if (d2 > trackWidth * trackWidth * progressOffRoadFactor * progressOffRoadFactor) {
			// drove off the road!
			activeIndexInChain[i] = -3;
		} else if (d2 > trackWidth * trackWidth * 0.25 * trackAllowanceFactor * trackAllowanceFactor) {
			const probes = 20;
			const probesOffset = 5;
			// check whether there are any gaps between the car and the presumed chain location
			for (let j = probesOffset; j < probes; ++j) {
				const pixelX = Math.round((carX + j * (chainX - carOffsetX) / probes) * trackDataScale);
				const pixelY = Math.round((carY + j * (chainY - carOffsetY) / probes) * trackDataScale);
				if (pixelX < 0 || pixelY < 0 || pixelX >= trackDataWidth || pixelY >= trackDataHeight || trackData[pixelY * trackDataWidth + pixelX] < 255)
					activeIndexInChain[i] = -3;
			}
		}
		debugString = `${debugString} ${i} ${activeIndex} ${Math.round(progress * 100)} /`;
	}
	// document.getElementById('debug').textContent = debugString;
	const progressThreshold = levels[currentLevel].progressThreshold ? levels[currentLevel].progressThreshold : 0.5;
	let anyActive = false;
	for (let i in chains) {
		const chain = chains[i];
		const activeIndex = activeIndexInChain[i];
		const progress = activeProgressInChain[i];
		if (activeIndex < 0)
			continue;
		anyActive = true;
		if (progress <= progressThreshold)
			continue;
		canFinishRace = true;
		if (activeIndex + 2 < chain.length) {
			activeIndexInChain[i]++;
			activeProgressInChain[i] = progressThreshold - 1;
			activePreviousPointForChain[i] = chain[activeIndex];
		} else {
			if (progress > 1 && !levels[currentLevel].ending)
				activeIndexInChain[i] = -1;
			let hasReset = false;
			for (let j in chains) {
				if (chain[chain.length - 1] !== chains[j][0])
					continue;
				if (chain[activeIndex] === chains[j][1]) {
					// don't allow back-and-forth paths.
					continue;
				}
				if (!hasReset) {
					activeIndexInChain[i] = -1;
					hasReset = true;
				}
				activeIndexInChain[j] = 0;
				activeProgressInChain[j] = progressThreshold - 1;
				activePreviousPointForChain[j] = chain[activeIndex];
			}
		}
	}
	if (!anyActive && gameState !== 'game-over')
		gameOver('You went the wrong way!', levels[currentLevel].ending ? 'ending error' : 'error');
}

const ccScale = 0.5;
const ccWidth = Math.round(viewportWidth * ccScale);
const ccHeight = Math.round(viewportHeight * ccScale);
// this is "good enough"
function ccFind(cc, index) {
	while (cc[index] !== 0) {
		const parent = index - cc[index];
		index = parent;
	}
	return index;
}
function ccUnion(cc, a, b) {
	if (cc[a] > a || cc[b] > b)
		return;
	a = ccFind(cc, a);
	b = ccFind(cc, b);
	if (a === b)
		return;
	else if (a > b) {
		cc[a] = a - b;
		return;
	} else {
		cc[b] = b - a;
		return;
	}
}
function ccCreate() {
	let start = performance.now();
	const cc = new Uint32Array(ccWidth * ccHeight);
	for (let i = 0; i < numberOfPointsInTrail; i++) {
		const trailX = Math.round(pointsInTrail[2 * i] * ccScale);
		const trailY = Math.round(pointsInTrail[2 * i + 1] * ccScale);
		if (trailX < 0 || trailY < 0 || trailX >= ccWidth || trailY >= ccHeight)
			continue;
		cc[trailY * ccWidth + trailX] = cc.length;
	}
	console.log(`elapsed fill: ${performance.now() - start}`);
	start = performance.now();
	let index = ccWidth + 1;
	// this loop misses one pixel at the top left... which is fine.
	for (let i = ccWidth + 1; i < ccWidth * ccHeight; ++i) {
		ccUnion(cc, i, i - ccWidth);
		ccUnion(cc, i, i - 1);
	}
	console.log(`elapsed union: ${performance.now() - start}`);
	return cc;
}

function checkSolved() {
	let solved = true;
	let connectedComponents = ccCreate();
	let ccForObject = [];
	for (let i = 0; i < objects.length; ++i) {
		const object = objects[i];
		if (object.destroyed)
			continue;
		const ccX = Math.round(object.x * ccScale);
		const ccY = Math.round(object.y * ccScale);
		if (ccX < 0 || ccY < 0 || ccX >= ccWidth || ccY >= ccHeight)
			ccForObject[i] = -1;
		else if (connectedComponents[ccY * ccWidth + ccX] > ccY * ccWidth + ccX)
			ccForObject[i] = -1;
		else
			ccForObject[i] = ccFind(connectedComponents, ccY * ccWidth + ccX);
	}
	for (let i = 0; i < objects.length; ++i) {
		const object = objects[i];
		if (object.destroyed)
			continue;
		switch (object.type) {
		case 'winding':
			let windingNumber = 0;
			for (let i = 1; i < numberOfPointsInTrail; i++) {
				const prevTrailX = pointsInTrail[2 * i - 2] - object.x;
				const prevTrailY = pointsInTrail[2 * i - 1] - object.y;
				const trailX = pointsInTrail[2 * i] - object.x;
				const trailY = pointsInTrail[2 * i + 1] - object.y;
				windingNumber += Math.atan2(prevTrailX * trailY - prevTrailY * trailX, prevTrailX * trailX + prevTrailY * trailY) / (Math.PI * 2);
			}
			if (Math.abs(windingNumber - object.winding) > 1e-3) {
				solved = false;
				object.flashMS = 900 * 999999;
			}
			break;
		case 'target':
			solved = false;
			object.flashMS = 900 * 999999;
			break;
		case 'match':
			const matchesRemaining = {};
			for (const match of object.matches) {
				if (matchesRemaining[match])
					matchesRemaining[match]++;
				else
					matchesRemaining[match] = 1;
			}
			for (let j = 0; j < objects.length; ++j) {
				if (objects[j].destroyed || j === i || ccForObject[j] !== ccForObject[i])
					continue;
				const border = objects[j].border;
				if (matchesRemaining.hasOwnProperty(border))
					matchesRemaining[objects[j].border]--;
			}
			for (const match in matchesRemaining) {
				if (matchesRemaining[match] !== 0) {
					solved = false;
					object.flashMS = 900 * 999999;
					break;
				}
			}
			break;
		default:
			break;
		}
	}
	if (solved) {
		gameOver('Finish!', 'finish');
		msUntilGameOverMessage = 1;
		if (levels[currentLevel].bestTime === 0 || raceTimerMinutes < levels[currentLevel].bestTimeMinutes || (raceTimerMinutes === levels[currentLevel].bestTimeMinutes && raceTimer < levels[currentLevel].bestTime)) {
			levels[currentLevel].bestTimeMinutes = raceTimerMinutes;
			levels[currentLevel].bestTime = raceTimer;
			localStorage.setItem(levels[currentLevel].name, JSON.stringify({ bestTimeMinutes: levels[currentLevel].bestTimeMinutes, bestTime: levels[currentLevel].bestTime }));
			newRecord = true;
		}
	} else {
		gameState = 'game-over';
		stopMS = 999999999;
		// ignoreInputMS = 2400;
		document.querySelector('main').className = 'buttons-only';
	}
}

function gameOver(message, className) {
	if (levels[currentLevel].name === 'free drive')
		return;
	gameState = 'game-over';
	msUntilGameOverMessage = msUntilGameOverMessageMax;
	gameOverMessage = message;
	gameOverMessageClassName = className;
}

function drawObject(ctx, object) {
	ctx.lineCap = 'round';
	ctx.lineJoin = 'round';
	const flashing = object.flashMS > 0 && ((Math.floor(object.flashMS / 300) % 3));

	if (object.destroyed && object.destroyMS < 150 && !((Math.floor(object.destroyMS / 30) % 2)))
		return;

	ctx.save();

	if (object.tilt) {
		ctx.translate(object.x, object.y);
		ctx.rotate(2 * Math.PI * object.tilt);
		ctx.translate(-object.x, -object.y);
	}

	let signHeight = 35;
	ctx.lineWidth = 6;
	if (object.maxDestroyMS === 0) {
		ctx.strokeStyle = '#433';
		ctx.beginPath();
		ctx.moveTo(object.x, object.y - signHeight);
		ctx.lineTo(object.x, object.y);
		ctx.stroke();
	} else {
		ctx.strokeStyle = '#544';
		signHeight = 5;
		ctx.beginPath();
		ctx.moveTo(object.x - 12, object.y - signHeight);
		ctx.lineTo(object.x - 15, object.y + 15);
		ctx.moveTo(object.x + 12, object.y - signHeight);
		ctx.lineTo(object.x + 15, object.y + 15);
		ctx.moveTo(object.x - 12, object.y + 8);
		ctx.lineTo(object.x + 12, object.y + 8);
		ctx.stroke();
	}

	ctx.beginPath();
	ctx.moveTo(object.x, object.y + 10 - 2 * signWidth - signHeight);
	ctx.lineTo(object.x + signWidth, object.y + 10 - signWidth - signHeight);
	ctx.lineTo(object.x, object.y + 10 - signHeight);
	ctx.lineTo(object.x - signWidth, object.y + 10 - signWidth - signHeight);
	ctx.closePath();
	ctx.fillStyle = flashing ? '#f00' : '#fee';
	ctx.fill();
	ctx.lineWidth = 12;
	ctx.strokeStyle = flashing ? '#f00' : '#fee';
	ctx.stroke();
	ctx.lineWidth = 6;
	ctx.strokeStyle = flashing ? '#fee' : object.border;
	ctx.stroke();

	ctx.save();
	ctx.translate(object.x, object.y + 10 - signWidth - signHeight);
	ctx.scale(signWidth, signWidth);

	switch (object.type) {
	case 'winding':

		let winding = object.winding;
		if (winding < 0) {
			ctx.scale(-1, 1);
			winding = -winding;
		}
		ctx.beginPath();
		ctx.arc(0, 1, 1, Math.PI + 1.05, 2 * Math.PI - 1.05);
		switch (winding) {
		case 0:
			break;
		case 1:
			ctx.moveTo(-0.05, -0.19);
			ctx.lineTo(0.15, 0.01);
			ctx.lineTo(-0.05, 0.21);
			break;
		case 2:
			ctx.save();
			ctx.translate(0.14 - 0.15, -0.18);
			ctx.rotate(Math.PI * -0.01);
			ctx.moveTo(-0.2, 0);
			ctx.lineTo(0, 0.2);
			ctx.lineTo(-0.2, 0.4);
			ctx.restore();
			ctx.save();
			ctx.translate(0.14 + 0.15, -0.17);
			ctx.rotate(Math.PI * 0.01);
			ctx.moveTo(-0.2, 0);
			ctx.lineTo(0, 0.2);
			ctx.lineTo(-0.2, 0.4);
			ctx.restore();
			break;
		default:
			break;
		}
		ctx.strokeStyle = flashing ? '#fee' : '#433';
		ctx.lineWidth = 0.15;
		ctx.stroke();

		break;
	case 'target':

		ctx.beginPath();
		ctx.arc(0, 0, 0.4, 0, 2 * Math.PI);
		ctx.strokeStyle = flashing ? '#fee' : '#433';
		ctx.lineWidth = 0.15;
		ctx.stroke();

		ctx.beginPath();
		ctx.arc(0, 0, 0.2, 0, 2 * Math.PI);
		ctx.fillStyle = flashing ? '#fee' : '#433';
		ctx.fill();

		break;
	case 'match':
		const size = 1 / (object.matches.length + 1);
		for (let i = 0; i < object.matches.length; ++i) {
			const x = (i + 0.5) / (object.matches.length) - 0.5;
			ctx.beginPath();
			ctx.moveTo(x, -size);
			ctx.lineTo(x - size, 0);
			ctx.lineTo(x, size);
			ctx.lineTo(x + size, 0);
			ctx.closePath();
			ctx.fillStyle = flashing ? '#f00' : '#fee';
			ctx.fill();
			ctx.lineWidth = 0.3 * size + 0.1;
			ctx.strokeStyle = flashing ? '#f00' : '#fee';
			ctx.stroke();
			ctx.lineWidth = 0.3 * size;
			ctx.strokeStyle = flashing ? '#fee' : object.matches[i];
			ctx.stroke();
		}

		break;

	default:
		break;
	}

	ctx.restore();

	if (showHitbox && !object.destroyed) {
		ctx.beginPath();
		ctx.arc(object.x, object.y, object.collisionRadius + carWidth / 2, 0, 2 * Math.PI, false);
		ctx.closePath();
		ctx.fillStyle = '#cc3333';
		ctx.fill();
	}

	ctx.restore();
}
function redraw() {

	let endingTranslation = 0;	
	if (endingMS > 0)
		endingTranslation = endingMS;
	document.getElementById('message').style.transform = `translate(0, -${endingTranslation}px)`;
	document.getElementById('ending-text').style.transform = `translate(0, -${endingTranslation}px)`;

	const ctx = canvas.getContext('2d');
	ctx.fillStyle = (gameState === 'loaded' && levels[currentLevel].name === 'free drive') ? '#a87' : '#fdc';
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	if (gameState === 'title')
		return;
	ctx.imageSmoothingEnabled = false;
	ctx.mozImageSmoothingEnabled = false;
	ctx.webkitImageSmoothingEnabled = false;
	ctx.save();
	ctx.scale(originalDevicePixelRatio, originalDevicePixelRatio);
	ctx.translate(0, -endingTranslation);

	ctx.strokeStyle = '#a87';
	ctx.lineWidth = trackWidth;
	ctx.lineCap = 'round';
	ctx.lineJoin = 'round';

	ctx.beginPath();
	for (const chain of chains) {
		let moved = false;
		for (const index of chain) {
			const x = points[index];
			const y = points[index + 1];
			if (!moved) {
				ctx.moveTo(x, y);
				moved = true;
			} else
				ctx.lineTo(x, y);
		}
	}
	ctx.stroke();

	if (levels[currentLevel].name !== 'free drive' && gameState !== 'level-select') {
		const startFinishX = points[chains[0][0]];
		const startFinishY = points[chains[0][0] + 1];
		ctx.save();
		ctx.transform(startFinishFacingX, startFinishFacingY, -startFinishFacingY, startFinishFacingX, startFinishX, startFinishY);
		let swap = false;
		const checkerboardSize = startFinishWidth / 2;
		for (let y = 0; y < trackWidth; y += checkerboardSize) {
			ctx.fillStyle = swap ? '#433' : '#fee';
			ctx.fillRect(0, y - trackWidth/2, checkerboardSize, checkerboardSize);
			ctx.fillStyle = swap ? '#fee' : '#433';
			ctx.fillRect(checkerboardSize, y - trackWidth / 2, checkerboardSize, checkerboardSize);
			swap = !swap;
		}
		ctx.restore();
	}

	ctx.fillStyle = '#976';
	ctx.strokeStyle = '#976';
	ctx.lineWidth = 5;
	for (let i = 0; i < directionIndicators.length; i += 4) {
		const chain = directionIndicators[i];
		const index = directionIndicators[i + 1];
		const progress = directionIndicators[i + 2];
		const gap = directionIndicators[i + 3];
		const x = points[chains[chain][index]];
		const y = points[chains[chain][index] + 1];
		let dx = points[chains[chain][index + 1]] - x;
		let dy = points[chains[chain][index + 1] + 1] - y;
		const cx = x + progress * dx;
		const cy = y + progress * dy;
		const d = Math.sqrt(dx * dx + dy * dy);
		dx /= d;
		dy /= d;
		ctx.beginPath();
		for (let j = -1; j <= 1; j += 2) {
			const ax = cx + j * dx * gap;
			const ay = cy + j * dy * gap;
			ctx.moveTo(ax + dx * 8, ay + dy * 8);
			ctx.lineTo(ax - dx * 8 - dy * 16, ay - dy * 8 + dx * 16);
			ctx.lineTo(ax - dx * 4, ay - dy * 4);
			ctx.lineTo(ax - dx * 8 + dy * 16, ay - dy * 8 - dx * 16);
			ctx.closePath();
		}
		ctx.fill();
		ctx.stroke();
	}

	if (levels[currentLevel].name === 'free drive' || gameState !== 'loaded')
		ctx.drawImage(trail, 0, 0, trail.width, trail.height, 0, 0, viewportWidth, viewportHeight);

	if (gameState !== 'level-select') {
		ctx.strokeStyle = '#000';
		ctx.lineWidth = carWidth;
		ctx.lineCap = 'butt';
		ctx.beginPath();
		const effectiveX = gameState === 'loaded' ? carX - introSlideDistance * introSlideFactor * facingX : carX;
		const effectiveY = gameState === 'loaded' ? carY - introSlideDistance * introSlideFactor * facingY : carY;
		ctx.moveTo(effectiveX - 0.5 * carLength * facingX, effectiveY - 0.5 * carLength * facingY);
		ctx.lineTo(effectiveX + 0.5 * carLength * facingX, effectiveY + 0.5 * carLength * facingY);
		ctx.stroke();
	}

	for (const object of objects)
		drawObject(ctx, object);

	if (showHitbox) {
		ctx.fillStyle = '#0004';
		for (let y = 0; y < trackDataHeight; ++y) {
			for (let x = 0; x < trackDataWidth; ++x) {
				if (trackData[y * trackDataWidth + x])
					ctx.fillRect(x / trackDataScale - 0.5 / trackDataScale, y / trackDataScale - 0.5 / trackDataScale, 1 / trackDataScale, 1 / trackDataScale);
			}
		}
	}


	if (gameState !== 'loaded' && gameState !== 'level-select' && !levels[currentLevel].ending) {
		ctx.fillStyle = '#433';
		if (gameState === 'game-over' && gameOverMessageClassName !== 'finish')
			ctx.fillStyle = '#a87';
		ctx.font = '24px Georgia';
		if (gameState === 'game-over' && gameOverMessageClassName === 'finish')
			ctx.font = 'bold 36px Georgia';
		ctx.textBaseline = 'top';
		ctx.fillText(formatTime(raceTimerMinutes, raceTimer), 20, 10);
		if (gameState === 'game-over' && gameOverMessageClassName === 'finish') {
			if (newRecord) {
				ctx.font = 'bold 24px Georgia';
				ctx.fillStyle = '#c33';
				ctx.fillText('New Best Time!', 20, 55);
			} else {
				ctx.font = '24px Georgia';
				ctx.fillText(`Best Time ${formatTime(levels[currentLevel].bestTimeMinutes, levels[currentLevel].bestTime)}`, 20, 55);
			}
		}
	}

	//Draw target indicator
	//ctx.fillStyle = "#5500aa"
	//ctx.fillRect(controllerX-5,controllerY-5,10,10);

	ctx.restore();
}
function tick(dt) {
	if (gameState === 'level-select' || gameState === 'title')
		return;
	let needsRedraw = false;
	dt *= tickFactor;
	const trailContext = trail.getContext('2d');
	trailContext.fillStyle = '#fff';
	dt += dtRemainder;
	dtRemainder = dt;
	for (let i = 0; i < Math.floor(dt); ++i) {
		dtRemainder = dt - i - 1;
		if (ignoreInputMS > 0)
			ignoreInputMS--;
		if (stopMS > 0)
			stopMS--;
		if (endingMS > 0 && endingMS < endingMSMax) {
			endingMS++;
			needsRedraw = true;
		}
		if (endingStartMS > 0) {
			if (!--endingStartMS) {
				endingMS = 1;
				needsRedraw = true;
			}
		}
		
		if (!frameAdvance || doFrame > 0) {
			getTasInputsGamePlay();
			if (controllerPressed && ignoreInputMS === 0 && stopMS === 0) {
				doFrame--;
				let dx = controllerX - carX;
				let dy = controllerY - carY;
				let d = Math.sqrt(dx * dx + dy * dy);
				if (d > 5) {
					dx /= d;
					dy /= d;
					const speedFactor =  Math.min(speed * 1.3, 1);
					const facingFactorFactor = 0.998 * speedFactor + 0.95 * (1 - speedFactor);
					const facingFactor = Math.pow(facingFactorFactor, speed);
					facingX = facingX * facingFactor + dx * (1 - facingFactor);
					facingY = facingY * facingFactor + dy * (1 - facingFactor);
					const len = Math.sqrt(facingX * facingX + facingY * facingY);
					facingX /= len;
					facingY /= len;
					const dot = facingX * dx + facingY * dy;
					if (dot > 0) {
						if (gameState === 'loaded' && levels[currentLevel].name !== 'free drive') {
							load();
							gameState = 'starting';
							if (!levels[currentLevel].ending) {
								document.querySelector('main').className = 'playing';
								document.getElementById('bottom-left-button').textContent = 'LEVEL SELECT';
								document.getElementById('bottom-right-button').textContent = 'RESTART';
							}
							needsRedraw = true;
						}
						const targetSpeed = Math.min(d / 300, 1);
						const factor = Math.pow(0.995, dot);
						speed = speed * factor + targetSpeed * (1 - factor);

					}
				}
			}
		}
		if (introSlideFactor > 1e-3) {
			introSlideFactor *= introSlideFactorDeceleration;
			needsRedraw = true;
		} else
			introSlideFactor = 0;
		if (stopMS === 0 && (!frameAdvance || doFrame > 0)) {
			speed *= 0.998;
			if (speed < 1e-3 && !controllerPressed)
				speed = 0;
			carX += facingX * speed;
			carY += facingY * speed;
			const r = 2;
			// const r = Math.round(Math.pow(Math.random(), 2) * 3);
			if (gameState !== 'starting') {
				trailContext.fillRect(Math.round((carX - r) * trailScale), Math.round((carY - r / 2) * trailScale), 2 * r * trailScale, r * trailScale);
				trailContext.fillRect(Math.round((carX - r / 2) * trailScale), Math.round((carY - r) * trailScale), r * trailScale, 2 * r * trailScale);
				if ((numberOfPointsInTrail + 800) * 2 + 1 < pointsInTrail.length) {
					pointsInTrail[numberOfPointsInTrail * 2] = carX;
					pointsInTrail[numberOfPointsInTrail * 2 + 1] = carY;
					if (numberOfPointsInTrail < 1 || pointsInTrail[numberOfPointsInTrail * 2] !== pointsInTrail[numberOfPointsInTrail * 2 - 2] || pointsInTrail[numberOfPointsInTrail * 2 - 1] !== pointsInTrail[numberOfPointsInTrail * 2 + 1])
						numberOfPointsInTrail++;
				} else if (gameState !== 'game-over')
					gameOver('Your time has run out!', 'error');
			}
			const startFinishX = points[chains[0][0]];
			const startFinishY = points[chains[0][0] + 1];
			let preX = carX - startFinishX;
			let preY = carY - startFinishY;
			if (canFinishRace) {
				preX += facingX * carLength / 2;
				preY += facingY * carLength / 2;
			}
			const carInStartFinishX = preX * startFinishFacingX + preY * startFinishFacingY;
			const carInStartFinishY = -preX * startFinishFacingY + preY * startFinishFacingX;
			if (Math.abs(carInStartFinishY) < trackWidth / 2 * trackAllowanceFactor * 1.05 && carInStartFinishX < startFinishWidth && carInStartFinishX > 0) {
				let headedForGoal = false;
				for (let i in chains) {
					if (activeIndexInChain[i] >= 0 && chains[i][activeIndexInChain[i]] === 0) {
						headedForGoal = true;
						break;
					}
				}
				if (gameState === 'starting')
					gameState = 'active';
				else if (headedForGoal && canFinishRace && gameState === 'active') {
					let closeDX = pointsInTrail[0] - carX;
					let closeDY = pointsInTrail[1] - carY;
					let dist = Math.sqrt(closeDX * closeDX + closeDY * closeDY);
					closeDX /= dist;
					closeDY /= dist;
					for (let i = 1; i < dist; ++i) {
						pointsInTrail[numberOfPointsInTrail * 2] = carX + i * closeDX;
						pointsInTrail[numberOfPointsInTrail * 2 + 1] = carY + i * closeDY;
						numberOfPointsInTrail++;
					}
					pointsInTrail[numberOfPointsInTrail * 2] = pointsInTrail[0];
					pointsInTrail[numberOfPointsInTrail * 2 + 1] = pointsInTrail[1];
					numberOfPointsInTrail++;
					checkSolved();
				}
			}
			const pixelX = Math.round(carX * trackDataScale);
			const pixelY = Math.round(carY * trackDataScale);
			if (pixelX < 0 || pixelY < 0 || pixelX >= trackDataWidth || pixelY >= trackDataHeight || trackData[pixelY * trackDataWidth + pixelX] < 255) {
				if (gameState !== 'game-over') {
					gameOver('You drove off the road!', levels[currentLevel].ending ? 'ending' : 'error');
					if (levels[currentLevel].ending)
						endingStartMS = 100;
				}
			}
			if (gameState !== 'game-over')
				updateProgress();
			if (gameState === 'active') {
				raceTimer++;
				while (raceTimer >= 60000) {
					raceTimer -= 60000;
					raceTimerMinutes++;
				}
				needsRedraw = true;
			}
		}
		if (msUntilGameOverMessage > 0) {
			if (--msUntilGameOverMessage === 0) {
				document.getElementById('message').textContent = gameOverMessage;
				document.querySelector('main').className = gameOverMessageClassName;
			}
			const t = msUntilGameOverMessage / msUntilGameOverMessageMax;
			tickFactor = t + 0.05 * (1 - t);
		}
		for (const object of objects) {
			if (object.flashMS > 0) {
				object.flashMS--;
				needsRedraw = true;
			}
			if (object.destroyMS > 0 && stopMS === 0) {
				object.destroyMS--;
				needsRedraw = true;
			}
			if (object.collisionRadius > 0 && gameState !== 'game-over') {
				const objX = object.x - carX;
				const objY = object.y - carY;
				const r = object.collisionRadius + carWidth / 2;
				if (objX * objX + objY * objY < r * r) {
					if (object.maxDestroyMS > 0) {
						if (!object.destroyed) {
							stopMS = 40;
							object.destroyMS = object.maxDestroyMS;
							object.destroyed = true;
							object.vx = facingX * speed * 2;
							object.vy = facingY * speed * 2 - 0.3;
							object.tilt = objX > 0 ? 0.05 : -0.05;
							if (objY > Math.abs(objX))
								object.tilt = -object.tilt;
							object.x += 10 * object.vx;
							object.y += 10 * object.vy;
						}
					} else {
						gameOver('You ran into a sign!', 'error');
						stopMS = 999999999;
					}
				}
			}
			if (object.vx !== 0 || object.vy !== 0) {
				if (stopMS === 0) {
					object.x += object.vx;
					object.y += object.vy;
					object.vx *= 0.998;
					object.vy *= 0.998;
					object.vy += 0.001;
				}
			}
		}
	}
	displayTasInfo();
	if (speed > 0 || needsRedraw)
		redraw();
}
canvas.width = viewportWidth * originalDevicePixelRatio;
canvas.height = viewportHeight * originalDevicePixelRatio;
canvas.style.width = viewportWidth + 'px';
canvas.style.height = viewportHeight + 'px';
trail.width = viewportWidth * trailScale;
trail.height = viewportHeight * trailScale;

redraw();

let lastTimestamp;
function animationFrame(timestamp) {
	let dt;
	if (lastTimestamp)
		dt = timestamp - lastTimestamp;
	lastTimestamp = timestamp;
	if (dt > 500) {
		// don't sim for too long if the timer is paused...
		dt = 500;
	}
	if (dt)
		tick(dt);
	requestAnimationFrame(animationFrame);
}
window.requestAnimationFrame(animationFrame);

/*
canvas.addEventListener('pointerdown', function (event) {
	controllerPressed = true;
	const rect = canvas.getBoundingClientRect();
	controllerX = event.clientX - rect.left;
	controllerY = event.clientY - rect.top;
	canvas.setPointerCapture(event.pointerId);
});

canvas.addEventListener('pointermove', function (event) {
	const rect = canvas.getBoundingClientRect();
	controllerX = event.clientX - rect.left;
	controllerY = event.clientY - rect.top;
});
canvas.addEventListener('pointerup', function (event) {
	controllerPressed = false;
});
canvas.addEventListener('pointercancel', function (event) {
	controllerPressed = false;
});
*/
canvas.addEventListener('touchstart', function (event) {
	event.preventDefault();
});


showTitleScreen();

// levelSelect();
for (let i = 0; i < levels.length; ++i) {
	if (levels[i].name[0] === '*') {
		setLevel(i);
		break;
	}
}

</script>
<script>let tasFiles = [];</script>
<!-- load your tasfile(s) here-->
<!--
<script src="tasFiles/racetrack.js"></script>
<script src="tasFiles/shortcut.js"></script>
<script src="tasFiles/not_so_fast.js"></script>
<script src="tasFiles/the_maze.js"></script>
<script src="tasFiles/two_birds.js"></script>
<script src="tasFiles/the_herby_derby.js"></script>
<script src="tasFiles/seeing_red.js"></script>
<script src="tasFiles/rose_tinted.js"></script>
<script src="tasFiles/nose_bridge.js"></script>
-->

<script src="tasFiles/racetrack.js"></script>
<script src="tasFiles/shortcut.js"></script>
<script src="tasFiles/not_so_fast.js"></script>
<script src="tasFiles/the_maze.js"></script>
<script src="tasFiles/two_birds.js"></script>
<script src="tasFiles/the_herby_derby.js"></script>
<script src="tasFiles/seeing_red.js"></script>
<script src="tasFiles/rose_tinted.js"></script>
<script src="tasFiles/nose_bridge.js"></script>

<script>
// tas stuff

var frameAdvance = false; //tasData.frameAdvance !== undefined;
var doFrame = 0; //tasData.skipFrames !== undefined ? tasData.skipFrames : 0;
var frameAdvanceRate = 0; //tasData.frameAdvance

var tasInputs;
var inputLine = [];
var inputLineCounter = [];
var tasInputCounter = 0;

var finishFrame;

document.onkeydown = function (event) {
	if (event.key == 'p'){
		doFrame = frameAdvanceRate;
	}
	if (event.key == 'o'){
		doFrame = 1;
	}
	if (event.key == 'i'){
		doFrame = Infinity;
	}
	if (event.key == '['){
		frameAdvance = true;
		doFrame = 0;
		frameAdvanceRate = 25;
	}
}

let mouseClickX;
let mouseClickY;

let forceStartPosX;
let forceStartPosY;

let forceCarFace;

let showHitbox = false;

canvas.addEventListener('pointerdown', function (event) {
	const rect = canvas.getBoundingClientRect();
	mouseClickX = event.clientX - rect.left;
	mouseClickY = event.clientY - rect.top;
});

function displayTasInfo(){
	let dx = controllerX - carX;
	let dy = controllerY - carY;
	let d = Math.sqrt(dx * dx + dy * dy);
	let targetSpeed = Math.min(d / 300, 1);
	document.getElementById("tas-info").innerText = `Speed:${speed}\nPos:(${carX},${carY})\nTargetSpeed:${targetSpeed}\nFacing:(${facingX},${facingY})\nFrame:${tasInputCounter}\nInputs:${tasInputs[tasInputCounter][0]},${tasInputs[tasInputCounter][1]}\nsource: Line ${inputLine[tasInputCounter]} frame ${inputLineCounter[tasInputCounter]}${gameState == "game-over" ? "\nFinish Frame:" + finishFrame + " (" + inputLine[tasInputCounter] + ":" + inputLineCounter[tasInputCounter+1] + ")": ""}${mouseClickX !== undefined ? "\nMousePos: (" + mouseClickX + "," + mouseClickY + ")": ""}\n\n---------`;
}

function parseInputLine(line, linenum){
	let stripped = line.replace(/\s/g, '');
	if (stripped == "") return [];
	if (stripped[0] == "#") return [];
	if (stripped == "***") return 0; //breakpoint
	if (stripped.includes(".")) return "ParseError: Fractional numbers are not allowed, happens at line " + linenum;

	let split = stripped.split(/[:|,]/);
	if (split.length == 1){
		return Array(parseInt(split[0])).fill(false);
	}
	if (split.length == 3){
		let x = parseInt(split[1]);
		let y = parseInt(split[2]);
		if (x < 0 || x > 800){
			return "ParseError: x out of boand at index " + linenum;
		}
		if (y < 0 || y > 800){
			return "ParseError: y out of boand at index " + linenum;
		}
		return Array(parseInt(split[0])).fill([x,y]);
	}
	return "ParseError: Line with weird format at index " + linenum;
}

function parseInputs(tasData){
	result = [];
	errors = [];
	failed = false;
	inputs = tasData.inputs.split("\n");
	for (let i=0; i<inputs.length; i++){
		let parsed = parseInputLine(inputs[i], i);
		if (typeof parsed == "string"){
			failed = true;
			errors.push(parsed);
		}
		else if (typeof parsed == "number"){
			if (parsed == 0){
				doFrame = result.length;
			}
		}
		else if (!failed){
			result = result.concat(parsed);
			inputLine = inputLine.concat(Array(parsed.length).fill(i));
			inputLineCounter = inputLineCounter.concat(Array.from(Array(parsed.length).keys()))
		}
	}
	if (failed){
		document.getElementById("tas-info").innerText = errors.join("\n");
	}
	else {
		tasInputs = result;

		if (tasData.loadLevel !== undefined){
			tasInputCounter = 0;

			if (tasData.startPos !== undefined){
				forceStartPosX = tasData.startPos[0];
				forceStartPosY = tasData.startPos[1];

				if (tasData.startFacing !== undefined){
					forceCarFace = tasData.startFacing;
				}
			}

			if (tasData.showHitbox !== undefined){
				showHitbox = tasData.showHitbox;
			}
			else {
				showHitbox = false;
			}

			setLevel(levels.findIndex(level => level.name == tasData.loadLevel))

			frameAdvance = tasData.frameAdvance !== undefined;
			doFrame = tasData.skipFrames !== undefined ? tasData.skipFrames : 0;
			frameAdvanceRate = tasData.frameAdvance;
			displayTasInfo();
		}
	}
}

let nextLevelCounter = 0;

function getTasInputsGamePlay(){
	if (gameState == "game-over"){
		if (nextLevelCounter == 0){
			nextLevelCounter++;
			updateTimer();
		}
		finishFrame = tasInputCounter;
		//controllerX = 0;
		//controllerY = 0;
		controllerPressed = true;
		if (tasFiles.length > tasFileCounter+1) {
			nextLevelCounter++;
			if (nextLevelCounter>50){
				controllerPressed = false;
				nextLevelCounter = 0;
				tasFileCounter++;
				parseInputs(tasFiles[tasFileCounter]);
			}
		}
		return;
	}
	if (tasInputCounter >= tasInputs.length) return;
	let input = tasInputs[tasInputCounter];
	tasInputCounter++;
	if (input === false){
		controllerPressed = false;
		return;
	}
	controllerX = input[0];
	controllerY = input[1];
	controllerPressed = true;
}

function setupTimes(){
	for (let file of tasFiles){
		let nameElem = document.createElement('td');
		nameElem.innerText = file.loadLevel;

		let timeElem = document.createElement('td');
		timeElem.id = "time-" + file.loadLevel;

		let rowElem = document.createElement('tr');
		rowElem.appendChild(nameElem);
		rowElem.appendChild(timeElem);

		document.getElementById("timer").children[0].insertBefore(rowElem, document.getElementById("totalRow"));
	}
}

let totalTime = 0;
let totalMinutes = 0;

function updateTimer(){
	let levelName = tasFiles[tasFileCounter].loadLevel;
	let time = raceTimer;
	totalTime += raceTimer;
	if (totalTime >= 60000){
		totalTime - 60000;
		totalMinutes++;
	}
	let formattedTime = formatTime(raceTimerMinutes, raceTimer);
	let formattedTotal = formatTime(totalMinutes, totalTime);

	document.getElementById("totalTime").innerText = formattedTotal;

	document.getElementById("time-" + levelName).innerText = formattedTime;
}

let tasFileCounter = 0;
setupTimes();
parseInputs(tasFiles[tasFileCounter]);

</script>
